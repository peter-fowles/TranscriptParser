# Question 1

P4: So, first problem, provide an algorithm to find the index i of log n. Okay, so it looks like… so this is a sorted array, and then 1, 3, 5, and then… It kind of, like, wraps around 6, 8, 12, 15. Okay. And then the answer is index 5, because, the start of the end is here. Hmm… Okay. So I feel like… I feel like the thing you're looking for is the first element. The key difference that I see is that this is the only element where Where it decreases. So there's only, in any given array that's being rotated, I think there's either gonna be… There's… there's only gonna be one or maybe zero elements that… such that… index i is less than index i-1. So… And all elements on the… so this will be two partitions of the array, so this side of the array must be greater than this entire side of the array. So… I guess, are you guaranteed that this first element is gonna be a part of, like, this left-rotated partition that's greater than the entire right side, or could… could you… could you have an array that's, like… 1, 2, 3, like, 12345, and then call, like, I don't know, like… I guess… I guess you wouldn't really have a rotation point. Because if you called 5 or 1 the rotation points, then the entire thing would get rotated around.

Interviewer: Yeah, so if we called… if we called 1 the rotation point, then it would just, like, in that sorted one, it would just not get rotated at all, so that would be, like, the rotation point is at index 1. If you called 5 the rotation point, it would actually have, like… that array would be, like, 5, 1, 2, 3, 4.

P4: Yeah, 524. Yeah, that makes sense. Okay, so… so this first element has to be greater than all elements in the… Right. partition, so…

Interviewer: Unless it's just, like, rotated at indexed one, which is just not rotated at all, right?

P4: Yeah, agreed.

Interviewer: Yep.

P4: So… so I think you would… You would run a binary search. for… The… element. Set for the element such that… It is the first element that is… Less than the… well, the… yeah, the first element is less than index 0. So… am I, like, writing out an algorithm, or how…

Interviewer: Yeah, just write, like, pseudocode, pretty much, doesn't have to be super precise, just, like, a general…

P4: Yeah. So, like, def Binary search. So, mid is equal to… I haven't done this in a while. Left, right… Mid is equal to equals right over 2. If… R… if… mid… Or if our mids is greater than… this grade with an R of 0… That means… Then you have less… then you move… over… Is that… I think it's, like, plus… I don't know, whatever. Okay. Oh, right. Okay. Okay. Okay. And then, it's greater… Then… Then you would move… So if it's greater than, you have to go more to the right. So left is equal to, is equal to mid plus 1. And then… Else. Then right would be equal to mid-1. And binary search are… Left, right, or something like that. And then also, like, the base case, if… I think you're looking for… if R… Oh, after that, after mid calculation, if R of mid… If R of mid… is greater than… are mid-minus 1, or less than. Then you can just return mid. Something along those lines, with, like, some off-by-one errors, I think. Yeah.

Interviewer: Yeah, that's a…

P4: by what ours.

Interviewer: I think that's a good overall structure. So how would you account for, those off-by-one errors, potentially?

P4: Probably run it in my head a couple times. So on this array, mid… so we have left is 0, 1, 2, 3, 4, 5, 6. So, we'd have left as… 0, 6, so middle would be 3. 0, 1, 2, 3, so this would be mid. And then… So this would be greater than the first elements, then we would say left is here. And then… So, left, right, then middle is here. So right would be here. So left is equal to right. So now mid would be here. Okay, so it solved this case. I guess. I guess just keep running cases, and try to find something that proves it wrong. I should… I feel like there's some edge case that would get this in, like, an infinite loop, because… there's not, like, an explicit… I feel… I feel like there's some case where it wouldn't actually hit this base case, so I might, like, just for my own sake, like, also just add, like, an if left is less than right, return mid, just in case to get it out of an infinite loop. But I feel like there's some case where this still wouldn't quite work.

Interviewer: Yeah.

P4: a little bit.

Interviewer: So, left is always less than right, like, as you're recursing, because…

P4: Oh, yeah, yeah, I've left them. Yeah. It's a good one, right?

Interviewer: Yeah, yeah, then, then, I think if, in fact, it's, if left is, like, greater than or equal to right, would do the trick. Because that would hit also the case where… I believe it would hit the case where the array is just sorted because it's rotated index 1.

P4: Oh, yeah, because then it would keep going… yeah.

Interviewer: Yeah, yeah, because then it just recurses down that way to the left side, sees, oh, there's… yeah, left is equal to right, and then we're there, because in that case, you'd hit an edge case where you'd have that off by one error with the mid-1, but yeah.

P4: That makes sense. Cool.

# Question 2

P4: You have an array of image or num, sort of a non-recasing order. Find the starting position, I'm gonna check a value, check it… Starting position of a target value, if the target is not far in the array. That's right. Okay. Isn't that just… like, a standard binary search? Binary search… I… Search… Target left… If… So… meta's left. I'll just write over 2… Eff. Rfmips… this target, or… I guess, at that best case. Turn those… And then… If our i is less than a target… An incident L. plus 2, plus 1… Else, then just increment. R… I… oh, and then also minus 1. Wait, so then… That would be this case.

Interviewer: Yes.

P4: If left is greater than… R, then return minus 1. Where's, I don't know, I think… I think that's right, I don't…

Interviewer: Yeah, so… I guess, read it in a couple of cases. Yeah, that finds, like, A, an instance of the target value, you gotta fight the starting position of that.

P4: Oh, starting.

Interviewer: Yep.

P4: Thanks. I answered the question. Okay. And then… Okay. Oh! Oh, I see. Hmm. Okay. Okay, first thought was to try to iterate backwards from the starting value, but obviously, if the whole array was the same element, then that would be an O .

Interviewer: Yeah.

P4: So I guess, if… R is less than target. So we could, rather than, rather than increment, and… Okay, if… If it's less than target, or… Cause we only want to… we only want to go to the right. If it's equal to the target, but it's not the first value, we want to go to the left. It's the only change that I think we would need to make. So… If it's equal to target, And… And… R of mid-1 is not equal to target. Then you would return it. And then… if… RFMID is… greater than… if… if it's… Equal the target. And it doesn't pass this case. Then… if it's equal, it's not gonna be less than. So, we're not gonna move. Okay, so it wouldn't… it wouldn't hit this case, it would hit this case, we'd move right back, which is what we would want. So I think, I think that would work.

Interviewer: Yeah, that does it.

# Question 3

P4: Suppose you're gonna have two unsorted arrays, A1 through N, BF1 through N, containing two indistinct integers. Such that A1 is less than B1, AN is greater than BN. Okay. Just trying to analyze the… let me get some… An efficient algorithm… to compute an index i such that… R of I is less than… Oh, so it's the last index such that A is greater than… A is less than B. Why does I always exist, intermediate Value Theorem? Yeah, because if at some point there has to be a value Such that… Such as, like, a change point. Okay. I also feel like this is… I mean, I might just copy the structure. Yoink? Okay. So, if… So, the goal is to find… it's kind of a little bit the opposite, so if I… So if R of mid… so if… okay, I guess A and B… So if A is less than B, So, here's our base case of Ave, I… is less than V of I. And… B of I plus 1 is less than… B of I plus 1.

Interviewer: Or greater than B of i plus 1, right?

P4: Oh yeah, greater than, sorry. Wait, is this… compute i such that, yeah. Can there be multiple transition points? Like, totally. Totally, yeah. But we're just trying to find one of them.

Interviewer: Yep.

P4: Okay. Not the first one.

Interviewer: Yeah, just an instance of it this time.

P4: Okay.

Interviewer: Yep.

P4: Okay, yeah, then this, this works. So if the return mid… Oh, it's return… oh, okay, we'll just call this I, then. Return i.e And then… there's never gonna be a return negative 1, because, yeah, there has to be an instance of it. And then… If… So if… R of I… is less… so if A is… A of i is less than B of I. then… And this would necessitate that A of i plus 1 is also less than B of I plus 1, because it didn't get trapped in that other case, so that would mean it would still be decreasing. And if it's… oh, wait, they have… no, increasing. It's increasing. Wait. No, it's relatively larger. B is… Relatively larger to A. And then… at some point to the right, there must be a point where A is relatively larger to B, so we want to go to the right. So that would… oh yeah, so increment L. And then… Otherwise, increment R. If… I guess, check edge cases for beginning and end, so if it's… A of… 2? If 2 is the one that it switches, then… Okay, so if 2 is the one where it switches… And I guess for the whole rest of the duration. A is greater than B, so A is… So A is greater than B, so it wouldn't satisfy this case. A is greater than B wouldn't satisfy this case, so then it would decrease R, So… Until mid is zero, and then it would satisfy. And then… if the transition point is the end, they're gonna make sure these indices work okay. If… so if it happens at… N. Then it would keep incrementing. I don't know. I'd be a little worried about, like, an index error, but I think logically it's fine. Like, an out-of-bounds error with that.

Interviewer: Yeah, that out of add there would, like, that would only be hit in, like, certain languages that don't immediately cut off in a Boolean if the first condition is not met in an AND.

P4: Oh, okay, cool.

Interviewer: Because it's, like, if it's N, A of i is never less than B of I, right? In that case? Yeah. Yeah, so… That's right. That's more of a semantic thing, I guess, with certain language.

P4: Got it, not a logical thing. Okay.

Interviewer: Yeah, so that looks, that looks great, yeah. 

P4: Awesome. 